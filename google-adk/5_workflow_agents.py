import os
import asyncio

from google.adk.agents import LlmAgent, ParallelAgent
from google.adk.tools.tool_context import ToolContext
from google.adk.agents import LoopAgent, LlmAgent, SequentialAgent
from google.adk.tools.tool_context import ToolContext
from google.adk.tools import google_search

from utils import call_agent_async, print_new_section
from settings import settings

os.environ["GOOGLE_API_KEY"] = settings.GOOGLE_API_KEY.get_secret_value()

"""
-------------------------------------------------------
In this example, we explore Google's ADK workflow agents with the following features:
- 1. Sequential Agents
- 2. Loop Agents
- 3. Parallel Agents

This section introduces "workflow agents" - specialized agents that control 
the execution flow of its sub-agents.
1. Sequential Agents
2. Loop Agents
3. Parallel Agents

Workflow agents are specialized components in ADK designed purely for orchestrating 
the execution flow of sub-agents.

Navigate to the above sections to see how each workflow agent works.
See more details in: https://google.github.io/adk-docs/agents/workflow-agents/
-------------------------------------------------------
"""


# ----------------------------------------------------------------
#                      1. Sequential Agents
# ----------------------------------------------------------------
# The SequentialAgent is a workflow agent that executes its sub-agents in the order they are specified in the list.
# Normally used when you want the execution to occur in a fixed, strict order.
# https://google.github.io/adk-docs/agents/workflow-agents/sequential-agents/

# --- 1. Create the 3 agents that will be used in the sequential agent ---
# 1.1. Code Writer Agent
# - Takes the initial specification (from user query) and writes code.
code_writer_agent = LlmAgent(
    name="code_writer_agent",
    model=settings.GOOGLE_MODEL_NAME,
    instruction=(
        "You are a Python Code Generator."
        "Based *only* on the user's request, write Python code that fulfills the requirement."
        "Output *only* the complete Python code block, enclosed in triple backticks (```python ... ```)."
        "Do not add any other text before or after the code block."
    ),
    description="Writes initial Python code based on a specification.",
    output_key="generated_code" # Stores output in state['generated_code']
)

# 1.2. Code Reviewer Agent
# - Takes the code generated by the previous agent (read from state) and provides feedback.
code_reviewer_agent = LlmAgent(
    name="code_reviewer_agent",
    model=settings.GOOGLE_MODEL_NAME,
    # Change 3: Improved instruction, correctly using state key injection
    instruction=(
        "You are an expert Python Code Reviewer."

        "  **Review this Python code:**"
        "  ```python"
        "  {generated_code}"
        "  ```"   

        "**Review Criteria:**"
        "1.  **Correctness:** Does it work? Any bugs?"
        "2.  **Readability:** Clear? PEP 8 compliant?"
        "3.  **Efficiency:** Any performance issues?"
        "4.  **Edge Cases:** Handles potential edge cases/unexpected inputs?"
        "5.  **Best Practices:** Follows Python best practices?"

        "**Output:**"
        "Provide your feedback as a concise, bulleted list. Focus on the most important points for improvement."
        "If the code is excellent and requires no changes, simply state: 'No major issues found.'"
        "Output *only* the review comments or the 'No major issues' statement."
    ),
    description="Reviews code and provides feedback.",
    output_key="review_comments", # Stores output in state['review_comments']
)


# 1.3. Code Refactorer Agent
# - Takes the original code and the review comments (read from state) and refactors the code.
code_refactorer_agent = LlmAgent(
    name="code_refactorer_agent",
    model=settings.GOOGLE_MODEL_NAME,
    # Change 3: Improved instruction, correctly using state key injection
    instruction=(
        "You are a Python Code Refactoring AI."
        "Your goal is to improve the given Python code based on the provided review comments."

        "**Original Code:**"
        "```python"
        "{generated_code}"
        "```"
        
        "**Review Comments:**"
        "{review_comments}"

        "**Task:**"
        "Carefully apply the suggestions from the review comments to refactor the original code."
        "If the review comments state 'No major issues found,' return the original code unchanged."
        "Ensure the final code is complete, and functional."

        "**Output:**"
        "Output *only* the final, refactored Python code block, enclosed in triple backticks (```python ... ```)."
        "Do not add any other text before or after the code block."
    ),
    description="Refactors code based on review comments.",
    output_key="refactored_code", # Stores output in state['refactored_code']
)


# --- 2. Create the SequentialAgent ---
# This agent orchestrates the pipeline by running the sub_agents in order.
code_pipeline_agent = SequentialAgent(
    name="code_pipeline_agent",
    sub_agents=[code_writer_agent, code_reviewer_agent, code_refactorer_agent],
    description="Executes a sequence of code writing, reviewing, and refactoring.",
    # The agents will run in the order provided: Writer -> Reviewer -> Refactorer
)

# --- 3. Run the pipeline agent ---
print_new_section("1. Sequential Agents")
input = "Write a Python function that fetches the current price of Bitcoin in USD."
print("Input: ", input)
asyncio.run(
    call_agent_async(code_pipeline_agent, input, tool_calls=True)
)
print("\n" + "-" * 50 + "\n")


# ----------------------------------------------------------------
#                      2. Loop Agents
# ----------------------------------------------------------------
# The LoopAgent is a workflow agent that executes its sub-agents in a loop (i.e. iteratively). 
# It repeatedly runs a sequence of agents for a specified number of iterations or until a termination condition is met.
# Normally used when you want the execution to occur in a loop, such as for iterative refinement or repeated tasks.
# https://google.github.io/adk-docs/agents/workflow-agents/loop-agents

# --- 0. Create the tool to exit the loop ---
def exit_loop(tool_context: ToolContext):
  """Call this function ONLY when the critique indicates no further changes are needed, signaling the iterative process should end."""
  print(f"  [Tool Call] exit_loop triggered by {tool_context.agent_name}")
  tool_context.actions.escalate = True
  # Return empty dict as tools should typically return JSON-serializable output
  return {}

# --- 1. Create the agents that will be used in the loop --
# 1.1. Initial Writer Agent (Runs ONCE at the beginning)
initial_writer_agent = LlmAgent(
    name="initial_writer_agent",
    model=settings.GOOGLE_MODEL_NAME,
    include_contents='none', # Controls content inclusion in model requests.
    instruction=(
        "You are a Creative Writing Assistant tasked with starting a story."
        "Write the *first draft* of a short story (aim for 2-4 sentences)."
        "Base the content *only* on the topic provided below."
        "Topic: {initial_topic}"

        "Output *only* the story/document text. Do not add introductions or explanations."
    ),
    description="Writes the initial document draft based on the topic, aiming for some initial substance.",
    output_key="current_document", # Stores output in state['current_document']
)

# 1.2. Critic Agent (Inside the Refinement Loop)
critic_agent_in_loop = LlmAgent(
    name="critic_agent_in_loop",
    model=settings.GOOGLE_MODEL_NAME,
    include_contents='none',
    instruction=(
        "You are a Constructive Critic AI reviewing a short story (typically 2-6 sentences). "
        "Your goal is balanced feedback."

        "**Document to Review:**"
        "```"
        "{current_document}"
        "```"

        "**Task:**"
        "Review the document for clarity, engagement, and basic coherence according to the initial topic (if known)."
        "You must guarantee that the story contains the name and age of the main character."

        "IF you identify 1-2 *clear and actionable* ways the document could be improved to better "
        "capture the topic or enhance reader engagement:"
        "Provide these specific suggestions concisely. Output *only* the critique text."

        "ELSE IF the document is coherent, and addresses the topic adequately for its length:"
        "Respond *exactly* with the phrase 'No major issues found.' and nothing else. It doesn't need to be perfect."

        "Do not add explanations. Output only the critique OR the exact completion phrase."
    ),
    description=(
        "Reviews the current draft, providing critique if clear improvements are "
        "needed, otherwise signals completion."
    ),
    output_key="criticism", # Stores output in state['criticism']
)


# 1.3. Refiner/Exiter Agent (Inside the Refinement Loop)
refiner_agent_in_loop = LlmAgent(
    name="refiner_agent_in_loop",
    model=settings.GOOGLE_MODEL_NAME,
    include_contents='none', 
    instruction=(
        "You are a Creative Writing Assistant refining a document based on feedback OR exiting the process."
        
        "**Current Document:**"
        "```"
        "{current_document}"
        "```"
        
        "**Critique/Suggestions:**"
        "{criticism}"

        "**Task:**"
        "Analyze the 'Critique/Suggestions'."
        "IF the critique is *exactly* 'No major issues found.':"
        "You MUST call the 'exit_loop' function. Do not output any text."
        "ELSE (the critique contains actionable feedback):"
        "Carefully apply the suggestions to improve the 'Current Document'. Output *only* the refined document text."

        "Do not add explanations. Either output the refined document OR call the exit_loop function."
    ),
    description=(
        "Refines the document based on critique, or "
        "calls `exit_loop` if critique indicates completion."
    ),
    tools=[exit_loop], # <-- HERE: Provide the exit_loop tool
    output_key="current_document" # Overwrites state['current_document'] with the refined version
)


# --- 2. Create the LoopAgent ---
# This agent orchestrates the iterative refinement process by running the sub_agents in a loop.
refinement_loop = LoopAgent(
    name="refinement_loop",
    # Agent order is crucial: Critique first, then Refine/Exit
    sub_agents=[
        critic_agent_in_loop,
        refiner_agent_in_loop,
    ],
    max_iterations=3 # Limit loops
)

# --- 3. Create a sequential agent that runs the initial writer and the refinement loop ---
# The order of execution will be: Initial Writer -> Refinement Loop -> Exit
loop_pipeline_agent = SequentialAgent(
    name="iterative_writing_pipeline",
    sub_agents=[
        initial_writer_agent, # Run first to create initial doc
        refinement_loop       # Then run the critique/refine loop
    ],
    description=(
        "Writes an initial document and then iteratively refines it "
        "with critique using an exit tool."
    )
)

# --- 4. Run the pipeline agent ---
print_new_section("2. Loop Agents")
input = "Write a short story about a robot learning to love."
print("Input: ", input)
asyncio.run(
    call_agent_async(loop_pipeline_agent, input, tool_calls=True, state={'initial_topic': input})
)
print("\n" + "-" * 50 + "\n")


# ----------------------------------------------------------------
#                      3. Parallel Agents
# ----------------------------------------------------------------
# The ParallelAgent is a workflow agent that executes its sub-agents concurrently. 
# This dramatically speeds up workflows where tasks can be performed independently.
# Normally used in scenarios prioritizing speed and involving independent, resource-intensive tasks.

# --- 1. Create the agents that will be used in parallel ---
# 1.1. Researcher 1: Renewable Energy
researcher_agent_1 = LlmAgent(
    name="renewable_energy_researcher",
    model=settings.GOOGLE_MODEL_NAME,
    instruction=(
        "You are an AI Research Assistant specializing in energy."
        "Research the latest advancements in 'renewable energy sources'."
        "Use the Google Search tool provided."
        "Summarize your key findings concisely (1-2 sentences)."
        "Output *only* the summary."
    ),
    description="Researches renewable energy sources.",
    tools=[google_search],
    # Store result in state for the merger agent
    output_key="renewable_energy_result"
)

# 1.2. Researcher 2: Electric Vehicles
researcher_agent_2 = LlmAgent(
    name="ev_technology_researcher",
    model=settings.GOOGLE_MODEL_NAME,
    instruction=(
        "You are an AI Research Assistant specializing in transportation."
        "Research the latest developments in 'electric vehicle technology'."
        "Use the Google Search tool provided."
        "Summarize your key findings concisely (1-2 sentences)."
        "Output *only* the summary."
    ),
    description="Researches electric vehicle technology.",
    tools=[google_search],
    # Store result in state for the merger agent
    output_key="ev_technology_result"
)

# --- 2. Create the ParallelAgent (Runs researchers concurrently) ---
# This agent orchestrates the concurrent execution of the researchers.
# It finishes once all researchers have completed and stored their results in state.
parallel_research_agent = ParallelAgent(
    name="parallel_research_agent",
    sub_agents=[researcher_agent_1, researcher_agent_2],
    description="Runs multiple research agents in parallel to gather information."
)

# --- 3. Define the Merger Agent (Runs *after* the parallel agents) ---
# This agent takes the results stored in the session state by the parallel agents
# and synthesizes them into a single, structured response with attributions.
merger_agent = LlmAgent(
    name="synthesis_agent",
    model=settings.GOOGLE_MODEL_NAME,
    instruction=(
        "You are an AI Assistant responsible for combining research findings "
        "into a structured report."

        "Your primary task is to synthesize the following research summaries, "
        "clearly attributing findings to their source areas. Structure your "
        "response using headings for each topic. Ensure the report is coherent "
        "and integrates the key points smoothly."

        "**Crucially: Your entire response MUST be grounded *exclusively* on "
        "the information provided in the 'Input Summaries' below. Do NOT add "
        "any external knowledge, facts, or details not present in these "
        "specific summaries.**"

        "**Input Summaries:**"

        "**Renewable Energy:**"
        "{renewable_energy_result}"

        "**Electric Vehicles:**"
        "{ev_technology_result}"


        "**Output Format:**"

        "## Summary of Recent Sustainable Technology Advancements"

        "### Renewable Energy Findings"
        "(Based on RenewableEnergyResearcher's findings)"
        "[Synthesize and elaborate *only* on the renewable energy input summary provided above.]"

        "### Electric Vehicle Findings"
        "(Based on EVResearcher's findings)"
        "[Synthesize and elaborate *only* on the EV input summary provided above.]"

        "### Overall Conclusion"
        "[Provide a brief (1-2 sentence) concluding statement that connects *only* the findings "
        "presented above.]"
        
        "Output *only* the structured report following this format. "
        "Do not include introductory or concluding phrases outside this structure, "
        "and strictly adhere to using only the provided input summary content."
    ),
    description="Combines research findings from parallel agents into a structured, cited report, strictly grounded on provided inputs.",
    # No tools needed for merging
    # No output_key needed here, as its direct response is the final output of the sequence
)


# --- 4. Create the SequentialAgent (Orchestrates the overall flow) ---
sequential_pipeline_agent = SequentialAgent(
    name="research_and_synthesis_pipeline",
    # The agents will run in the order provided: Parallel Research -> Merger
    sub_agents=[parallel_research_agent, merger_agent],
    description="Coordinates parallel research and synthesizes the results."
)

# --- 5. Run the pipeline agent ---
print_new_section("3. Parallel Agents")
input = "Research the latest sustainable technology advancements."
print("Input: ", input)
asyncio.run(
    call_agent_async(sequential_pipeline_agent, input, tool_calls=True)
)
